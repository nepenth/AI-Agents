/**\n * Test Suite for Enhanced SocketIO Manager\n * \n * Comprehensive tests for the enhanced SocketIO client functionality\n * including event validation, reconnection, buffering, and error handling.\n */\n\nclass EnhancedSocketIOManagerTester {\n    constructor() {\n        this.testResults = [];\n        this.mockSocket = null;\n        this.manager = null;\n    }\n    \n    async runAllTests() {\n        console.log('üß™ Starting Enhanced SocketIO Manager Test Suite...');\n        \n        const tests = [\n            this.testInitialization,\n            this.testEventValidation,\n            this.testEventHandling,\n            this.testBatchEventHandling,\n            this.testConnectionManagement,\n            this.testReconnectionLogic,\n            this.testEventBuffering,\n            this.testHeartbeat,\n            this.testStatusCallbacks,\n            this.testErrorHandling\n        ];\n        \n        for (const test of tests) {\n            try {\n                await test.call(this);\n            } catch (error) {\n                this.addTestResult(test.name, false, `Test threw error: ${error.message}`);\n            }\n        }\n        \n        this.displayResults();\n        return this.getTestSummary();\n    }\n    \n    setupMockSocket() {\n        this.mockSocket = {\n            id: 'mock-socket-id',\n            connected: false,\n            disconnected: true,\n            on: jest.fn ? jest.fn() : function(event, handler) {\n                this._handlers = this._handlers || {};\n                this._handlers[event] = this._handlers[event] || [];\n                this._handlers[event].push(handler);\n            },\n            emit: jest.fn ? jest.fn() : function(event, data) {\n                console.log(`Mock emit: ${event}`, data);\n            },\n            disconnect: jest.fn ? jest.fn() : function() {\n                this.connected = false;\n                this.disconnected = true;\n            },\n            _trigger: function(event, data) {\n                if (this._handlers && this._handlers[event]) {\n                    this._handlers[event].forEach(handler => handler(data));\n                }\n            }\n        };\n        \n        // Mock window.io\n        window.io = () => this.mockSocket;\n    }\n    \n    testInitialization() {\n        console.log('üîç Testing initialization...');\n        \n        this.setupMockSocket();\n        \n        try {\n            this.manager = new EnhancedSocketIOManager({\n                autoConnect: false,\n                maxReconnectAttempts: 3\n            });\n            \n            // Check initial state\n            if (!this.manager.validator) {\n                throw new Error('Validator not initialized');\n            }\n            \n            if (this.manager.isConnected) {\n                throw new Error('Should not be connected initially with autoConnect: false');\n            }\n            \n            const status = this.manager.getStatus();\n            if (!status || typeof status.isConnected !== 'boolean') {\n                throw new Error('Invalid status object');\n            }\n            \n            this.addTestResult('testInitialization', true, 'Manager initialized correctly');\n            \n        } catch (error) {\n            this.addTestResult('testInitialization', false, error.message);\n        }\n    }\n    \n    testEventValidation() {\n        console.log('üîç Testing event validation...');\n        \n        try {\n            const validator = new SocketEventValidator();\n            \n            // Test valid log event\n            const validLog = {\n                message: 'Test log message',\n                level: 'INFO'\n            };\n            \n            const logResult = validator.validateEvent('log', validLog);\n            if (!logResult.isValid) {\n                throw new Error(`Valid log event failed validation: ${logResult.error}`);\n            }\n            \n            // Test invalid phase event\n            const invalidPhase = {\n                phase_id: 'test_phase',\n                status: 'invalid_status'\n            };\n            \n            const phaseResult = validator.validateEvent('phase_update', invalidPhase);\n            if (phaseResult.isValid) {\n                throw new Error('Invalid phase event should fail validation');\n            }\n            \n            // Test progress event with percentage calculation\n            const progressEvent = {\n                processed_count: 7,\n                total_count: 10\n            };\n            \n            const progressResult = validator.validateEvent('progress_update', progressEvent);\n            if (!progressResult.isValid) {\n                throw new Error(`Valid progress event failed validation: ${progressResult.error}`);\n            }\n            \n            if (progressResult.sanitizedData.percentage !== 70) {\n                throw new Error(`Incorrect percentage calculation: ${progressResult.sanitizedData.percentage}`);\n            }\n            \n            this.addTestResult('testEventValidation', true, 'Event validation working correctly');\n            \n        } catch (error) {\n            this.addTestResult('testEventValidation', false, error.message);\n        }\n    }\n    \n    testEventHandling() {\n        console.log('üîç Testing event handling...');\n        \n        try {\n            if (!this.manager) {\n                throw new Error('Manager not initialized');\n            }\n            \n            let receivedEvent = null;\n            let receivedData = null;\n            \n            // Register event handler\n            const unsubscribe = this.manager.on('test_event', (data, eventName) => {\n                receivedEvent = eventName;\n                receivedData = data;\n            });\n            \n            // Simulate incoming event\n            this.manager.handleIncomingEvent('test_event', { test: 'data' });\n            \n            if (receivedEvent !== 'test_event') {\n                throw new Error(`Expected 'test_event', got '${receivedEvent}'`);\n            }\n            \n            if (!receivedData || receivedData.test !== 'data') {\n                throw new Error('Event data not received correctly');\n            }\n            \n            // Test unsubscribe\n            unsubscribe();\n            receivedEvent = null;\n            \n            this.manager.handleIncomingEvent('test_event', { test: 'data2' });\n            \n            if (receivedEvent !== null) {\n                throw new Error('Event handler not unsubscribed correctly');\n            }\n            \n            this.addTestResult('testEventHandling', true, 'Event handling working correctly');\n            \n        } catch (error) {\n            this.addTestResult('testEventHandling', false, error.message);\n        }\n    }\n    \n    testBatchEventHandling() {\n        console.log('üîç Testing batch event handling...');\n        \n        try {\n            if (!this.manager) {\n                throw new Error('Manager not initialized');\n            }\n            \n            const receivedEvents = [];\n            \n            // Register event handler\n            this.manager.on('log', (data) => {\n                receivedEvents.push(data);\n            });\n            \n            // Simulate batch event\n            const batchData = {\n                events: [\n                    { message: 'Log 1', level: 'INFO' },\n                    { message: 'Log 2', level: 'WARNING' },\n                    { message: 'Log 3', level: 'ERROR' }\n                ],\n                count: 3\n            };\n            \n            this.manager.handleBatchEvent('log', batchData);\n            \n            if (receivedEvents.length !== 3) {\n                throw new Error(`Expected 3 events, got ${receivedEvents.length}`);\n            }\n            \n            if (receivedEvents[0].message !== 'Log 1') {\n                throw new Error('First batch event not processed correctly');\n            }\n            \n            this.addTestResult('testBatchEventHandling', true, 'Batch event handling working correctly');\n            \n        } catch (error) {\n            this.addTestResult('testBatchEventHandling', false, error.message);\n        }\n    }\n    \n    testConnectionManagement() {\n        console.log('üîç Testing connection management...');\n        \n        try {\n            if (!this.manager) {\n                throw new Error('Manager not initialized');\n            }\n            \n            // Test initial state\n            if (this.manager.isConnected) {\n                throw new Error('Should not be connected initially');\n            }\n            \n            // Simulate connection\n            this.manager.isConnected = false;\n            this.manager.handleConnect();\n            \n            if (!this.manager.isConnected) {\n                throw new Error('Should be connected after handleConnect');\n            }\n            \n            if (this.manager.isConnecting) {\n                throw new Error('Should not be connecting after successful connection');\n            }\n            \n            // Simulate disconnection\n            this.manager.handleDisconnect('transport close');\n            \n            if (this.manager.isConnected) {\n                throw new Error('Should not be connected after disconnect');\n            }\n            \n            this.addTestResult('testConnectionManagement', true, 'Connection management working correctly');\n            \n        } catch (error) {\n            this.addTestResult('testConnectionManagement', false, error.message);\n        }\n    }\n    \n    testReconnectionLogic() {\n        console.log('üîç Testing reconnection logic...');\n        \n        try {\n            if (!this.manager) {\n                throw new Error('Manager not initialized');\n            }\n            \n            // Reset connection attempts\n            this.manager.connectionAttempts = 0;\n            \n            // Test reconnection scheduling\n            this.manager.scheduleReconnection();\n            \n            if (!this.manager.reconnectTimer) {\n                throw new Error('Reconnection timer not set');\n            }\n            \n            // Test max attempts\n            this.manager.connectionAttempts = this.manager.options.maxReconnectAttempts;\n            \n            // Clear existing timer\n            if (this.manager.reconnectTimer) {\n                clearTimeout(this.manager.reconnectTimer);\n                this.manager.reconnectTimer = null;\n            }\n            \n            this.manager.scheduleReconnection();\n            \n            if (this.manager.reconnectTimer) {\n                throw new Error('Should not schedule reconnection after max attempts');\n            }\n            \n            this.addTestResult('testReconnectionLogic', true, 'Reconnection logic working correctly');\n            \n        } catch (error) {\n            this.addTestResult('testReconnectionLogic', false, error.message);\n        }\n    }\n    \n    testEventBuffering() {\n        console.log('üîç Testing event buffering...');\n        \n        try {\n            if (!this.manager) {\n                throw new Error('Manager not initialized');\n            }\n            \n            // Ensure not connected\n            this.manager.isConnected = false;\n            \n            // Buffer some events\n            this.manager.bufferEvent('test_event', { data: 1 });\n            this.manager.bufferEvent('test_event', { data: 2 });\n            \n            if (this.manager.eventBuffer.length !== 2) {\n                throw new Error(`Expected 2 buffered events, got ${this.manager.eventBuffer.length}`);\n            }\n            \n            // Test buffer processing\n            const receivedEvents = [];\n            this.manager.on('test_event', (data) => {\n                receivedEvents.push(data);\n            });\n            \n            this.manager.processBufferedEvents();\n            \n            if (receivedEvents.length !== 2) {\n                throw new Error(`Expected 2 processed events, got ${receivedEvents.length}`);\n            }\n            \n            if (this.manager.eventBuffer.length !== 0) {\n                throw new Error('Event buffer should be empty after processing');\n            }\n            \n            this.addTestResult('testEventBuffering', true, 'Event buffering working correctly');\n            \n        } catch (error) {\n            this.addTestResult('testEventBuffering', false, error.message);\n        }\n    }\n    \n    testHeartbeat() {\n        console.log('üîç Testing heartbeat functionality...');\n        \n        try {\n            if (!this.manager) {\n                throw new Error('Manager not initialized');\n            }\n            \n            // Test heartbeat start\n            this.manager.startHeartbeat();\n            \n            if (!this.manager.heartbeatTimer) {\n                throw new Error('Heartbeat timer not started');\n            }\n            \n            // Test heartbeat stop\n            this.manager.stopHeartbeat();\n            \n            if (this.manager.heartbeatTimer) {\n                throw new Error('Heartbeat timer not stopped');\n            }\n            \n            // Test heartbeat handling\n            this.manager.handleHeartbeat();\n            // Should not throw error\n            \n            this.addTestResult('testHeartbeat', true, 'Heartbeat functionality working correctly');\n            \n        } catch (error) {\n            this.addTestResult('testHeartbeat', false, error.message);\n        }\n    }\n    \n    testStatusCallbacks() {\n        console.log('üîç Testing status callbacks...');\n        \n        try {\n            if (!this.manager) {\n                throw new Error('Manager not initialized');\n            }\n            \n            let receivedStatus = null;\n            \n            // Register status callback\n            const unsubscribe = this.manager.onStatusChange((status) => {\n                receivedStatus = status;\n            });\n            \n            // Trigger status change\n            this.manager.notifyStatusChange('connected', 'Test connection');\n            \n            if (!receivedStatus) {\n                throw new Error('Status callback not called');\n            }\n            \n            if (receivedStatus.status !== 'connected') {\n                throw new Error(`Expected 'connected', got '${receivedStatus.status}'`);\n            }\n            \n            if (receivedStatus.message !== 'Test connection') {\n                throw new Error(`Expected 'Test connection', got '${receivedStatus.message}'`);\n            }\n            \n            // Test unsubscribe\n            unsubscribe();\n            receivedStatus = null;\n            \n            this.manager.notifyStatusChange('disconnected', 'Test disconnect');\n            \n            if (receivedStatus !== null) {\n                throw new Error('Status callback not unsubscribed correctly');\n            }\n            \n            this.addTestResult('testStatusCallbacks', true, 'Status callbacks working correctly');\n            \n        } catch (error) {\n            this.addTestResult('testStatusCallbacks', false, error.message);\n        }\n    }\n    \n    testErrorHandling() {\n        console.log('üîç Testing error handling...');\n        \n        try {\n            if (!this.manager) {\n                throw new Error('Manager not initialized');\n            }\n            \n            // Test connection error handling\n            const testError = new Error('Test connection error');\n            this.manager.handleConnectionError(testError);\n            \n            if (this.manager.isConnecting) {\n                throw new Error('Should not be connecting after error');\n            }\n            \n            if (this.manager.eventStats.errors === 0) {\n                throw new Error('Error count not incremented');\n            }\n            \n            // Test invalid event handling\n            const initialErrors = this.manager.eventStats.errors;\n            \n            // This should increment error count due to validation failure\n            this.manager.handleIncomingEvent('phase_update', {\n                phase_id: 'test',\n                status: 'invalid_status'\n            });\n            \n            if (this.manager.eventStats.errors <= initialErrors) {\n                throw new Error('Error count not incremented for invalid event');\n            }\n            \n            this.addTestResult('testErrorHandling', true, 'Error handling working correctly');\n            \n        } catch (error) {\n            this.addTestResult('testErrorHandling', false, error.message);\n        }\n    }\n    \n    addTestResult(testName, passed, message) {\n        this.testResults.push({\n            test: testName,\n            passed,\n            message,\n            timestamp: new Date().toISOString()\n        });\n        \n        const status = passed ? '‚úÖ' : '‚ùå';\n        console.log(`${status} ${testName}: ${message}`);\n    }\n    \n    displayResults() {\n        console.log('\\nüìä Test Results Summary:');\n        console.log('=' .repeat(50));\n        \n        const passed = this.testResults.filter(r => r.passed).length;\n        const total = this.testResults.length;\n        \n        console.log(`Total Tests: ${total}`);\n        console.log(`Passed: ${passed}`);\n        console.log(`Failed: ${total - passed}`);\n        console.log(`Success Rate: ${((passed / total) * 100).toFixed(1)}%`);\n        \n        console.log('\\nüìã Detailed Results:');\n        this.testResults.forEach(result => {\n            const status = result.passed ? '‚úÖ' : '‚ùå';\n            console.log(`${status} ${result.test}: ${result.message}`);\n        });\n        \n        if (passed === total) {\n            console.log('\\nüéâ All tests passed! Enhanced SocketIO Manager is working correctly.');\n        } else {\n            console.log(`\\n‚ö†Ô∏è ${total - passed} test(s) failed. Please review the implementation.`);\n        }\n    }\n    \n    getTestSummary() {\n        const passed = this.testResults.filter(r => r.passed).length;\n        const total = this.testResults.length;\n        \n        return {\n            total,\n            passed,\n            failed: total - passed,\n            successRate: (passed / total) * 100,\n            allPassed: passed === total,\n            results: this.testResults\n        };\n    }\n}\n\n// Auto-run tests if this script is loaded directly\nif (typeof window !== 'undefined' && window.EnhancedSocketIOManager) {\n    // Wait for DOM to be ready\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', () => {\n            const tester = new EnhancedSocketIOManagerTester();\n            tester.runAllTests();\n        });\n    } else {\n        const tester = new EnhancedSocketIOManagerTester();\n        tester.runAllTests();\n    }\n}\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = EnhancedSocketIOManagerTester;\n} else {\n    window.EnhancedSocketIOManagerTester = EnhancedSocketIOManagerTester;\n}"