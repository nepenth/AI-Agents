from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Set, Any

from pydantic import BaseModel, Field, HttpUrl, field_validator, model_validator


class MediaItem(BaseModel):
    """Represents a single media item associated with a tweet."""
    original_url: HttpUrl
    local_path: Optional[Path] = None # Path where the media is cached
    type: Optional[str] = None # e.g., 'image', 'video', 'gif' - auto-detected or from source
    description: Optional[str] = None # Generated by vision model

    @field_validator("local_path", mode="before")
    @classmethod
    def validate_path(cls, v):
        if v is not None and not isinstance(v, Path):
            return Path(v)
        return v


class TweetData(BaseModel):
    """
    Core data structure representing a tweet and its processing state.
    This model serves as the primary record in the tweet_cache.
    """
    tweet_id: str = Field(..., description="The unique identifier of the tweet.")
    author_handle: Optional[str] = None
    author_id: Optional[str] = None # Add author ID for thread checking
    author_name: Optional[str] = None
    created_at: Optional[datetime] = None
    text: Optional[str] = None
    thread_tweets: List[Dict[str, Any]] = Field(default_factory=list, description="List of subsequent thread tweet dicts by the same author.") # Store basic info
    combined_text: Optional[str] = None # Combined text of main tweet + thread
    source_url: Optional[HttpUrl] = Field(None, description="The direct URL to the tweet.")
    expanded_urls: Dict[str, HttpUrl] = Field(default_factory=dict, description="Mapping of shortened URLs to their expanded forms.")
    media_items: List[MediaItem] = Field(default_factory=list)
    referenced_tweets: List[str] = Field(default_factory=list, description="IDs of tweets referenced (e.g., quotes, replies)") # Future use?

    # Processing Status Flags
    cache_complete: bool = Field(default=False, description="Phase 1: Core data and media files cached/validated.")
    media_processed: bool = Field(default=False, description="Phase 2: Media interpretation (e.g., descriptions) complete.")
    categories_processed: bool = Field(default=False, description="Phase 3: Categories and item name assigned.")
    kb_item_created: bool = Field(default=False, description="Phase 4: Knowledge base item (README, media) generated.")
    db_synced: bool = Field(default=False, description="Phase 5: Entry synced with the local SQLite DB.")

    # Generated Content/Metadata
    main_category: Optional[str] = None
    sub_category: Optional[str] = None
    item_name: Optional[str] = None # Generated name for the KB item directory/entry
    generated_content: Optional[str] = None # The generated README content (Phase 4)

    # Knowledge Base Output Info
    kb_item_path: Optional[Path] = Field(None, description="Path to the generated KB item directory.")
    kb_media_paths: List[Path] = Field(default_factory=list, description="Paths to media files copied into the KB item directory.")

    # Error Tracking
    error_message: Optional[str] = None # Record the first error encountered during processing
    failed_phase: Optional[str] = None # Record the name of the phase that failed

    @field_validator("kb_item_path", mode="before")
    @classmethod
    def validate_kb_item_path(cls, v):
         # Allow None, otherwise convert to Path
         if v is not None and not isinstance(v, Path):
             return Path(v)
         return v

    @field_validator("kb_media_paths", mode="before")
    @classmethod
    def validate_kb_media_paths(cls, v):
        # Ensure list contains Path objects
        if isinstance(v, list):
             return [Path(p) if not isinstance(p, Path) else p for p in v]
        return v # Allow empty list or potentially None if default_factory wasn't used

    @model_validator(mode='after')
    def compute_combined_text(self) -> "TweetData":
        """Combines the main text and thread tweet texts."""
        if not self.text and not self.thread_tweets:
             self.combined_text = None
             return self

        all_texts = []
        if self.text:
             all_texts.append(self.text)

        # Sort thread tweets chronologically before combining
        sorted_threads = sorted(self.thread_tweets, key=lambda t: t.get('created_at', datetime.min))

        for i, thread_tweet in enumerate(sorted_threads):
             thread_text = thread_tweet.get('text')
             if thread_text:
                  all_texts.append(f"\n\n--- (Thread Part {i+1}) ---\n{thread_text}") # Add separator

        self.combined_text = "".join(all_texts)
        return self

    def mark_failed(self, phase: str, error: Exception | str):
        """Updates the status to reflect a processing failure."""
        self.failed_phase = phase
        self.error_message = str(error)
        # Consider resetting downstream flags if a phase fails, preventing further processing
        # Example: If caching fails, subsequent phases shouldn't run.
        if phase.lower() in ["caching", "cache"]:
            self.cache_complete = False # Explicitly mark as not complete if it failed
        # Similar logic could apply to other phases if needed.

    def needs_processing(self, phase: str) -> bool:
        """
        Checks if a specific processing phase needs to run for this tweet based on its current state.
        Does not account for external flags like FORCE_RECACHE.
        """
        if self.error_message: # Don't process further if already failed
            return False

        phase_lower = phase.lower()

        if phase_lower in ["caching", "cache"]:
            return not self.cache_complete
        elif phase_lower in ["interpretation", "interpret"]:
            # Requires cache complete, media not processed, and actual image media to interpret
            has_media_to_interpret = any(m.type == 'image' and m.description is None for m in self.media_items)
            return self.cache_complete and not self.media_processed and has_media_to_interpret
        elif phase_lower in ["categorization", "categorize"]:
            # Requires cache and media processing done, but categories not yet assigned
            return self.cache_complete and self.media_processed and not self.categories_processed
        elif phase_lower in ["generation", "generate"]:
            # Requires all prior steps done, but KB item not created
            return self.cache_complete and self.media_processed and self.categories_processed and not self.kb_item_created
        elif phase_lower in ["dbsync", "sync", "database", "db_sync"]:
             # Requires KB item created but not marked synced
            return self.kb_item_created and not self.db_synced
        else:
            # Unknown phase or phases handled differently (e.g., Indexing, Git Sync)
            return False


class ProcessingState(BaseModel):
    """Represents the overall state managed by the StateManager."""
    unprocessed_tweet_ids: Set[str] = Field(default_factory=set)
    processed_tweet_ids: Set[str] = Field(default_factory=set)
    # Using dict allows easy lookup by ID. Key is tweet_id.
    tweet_cache: Dict[str, TweetData] = Field(default_factory=dict)

    # Metadata or statistics could also be added here
    last_run_timestamp: Optional[datetime] = None


# --- Database Related Types ---
# Defines the structure expected for interacting with the DB layer.
# The actual SQLAlchemy model might differ slightly (e.g., relationships).

class KnowledgeBaseItemRecord(BaseModel):
    """Pydantic model representing a record in the knowledge base summary DB."""
    # Note: Primary key (id) is often handled by SQLAlchemy automatically
    tweet_id: str = Field(..., description="Original tweet ID.", index=True) # Indexing likely needed
    item_name: str = Field(...)
    main_category: str = Field(...)
    sub_category: str = Field(...)
    kb_item_path: Path = Field(..., description="Path relative to KNOWLEDGE_BASE_DIR")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    last_updated_at: datetime = Field(default_factory=datetime.utcnow)
    source_url: Optional[HttpUrl] = None
    author_handle: Optional[str] = None # Denormalized for easier display?
    text_preview: Optional[str] = None # Denormalized for easier display?

    @field_validator("kb_item_path", mode="before")
    @classmethod
    def validate_path(cls, v):
         if not isinstance(v, Path):
             return Path(v)
         return v

    # Pydantic configuration for ORM mode if needed later
    # model_config = ConfigDict(from_attributes=True)
